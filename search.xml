<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo Grammar</title>
      <link href="/2020/05/15/Hexo%20Grammar/"/>
      <url>/2020/05/15/Hexo%20Grammar/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>nodejs,cnpm:</li></ul><p>首先要安装 Node.Js,顺带会有npm</p><p>本来是用npm来安装Hexo,但因为国内镜像系统较慢，利用npm安装cnpm也就是淘宝</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p><code>node -v</code>验证    <code>npm -v</code>验证</p><ul><li>hexo:</li></ul><p>安装Hexo:<code>cnpm install -g hexo-cli</code></p><p><code>hexo -v</code>验证</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>初始化博客</li></ul><p><code>mkdir blog</code></p><p><code>cd blog</code></p><p><code>sudo hexo init</code></p><ul><li>启动博客</li></ul><p><code>hexo s</code>用来预览</p><ul><li>创建博客</li></ul><p><code>hexo n &quot;name&quot;</code></p><h2 id="部署远端-cg-github"><a href="#部署远端-cg-github" class="headerlink" title="部署远端(cg:github)"></a>部署远端(cg:github)</h2><p>安装git部署插件： <code>cnpm install --save hexo-deployer-git</code></p><p>配置远端地址_config.yml:</p><p><code>vim _config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: https://github.com/Eastwood6/Eastwood6.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: root@47.110.150.78:/home/git/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thingking In Java Notes</title>
      <link href="/2020/05/15/ThinkingInJava/"/>
      <url>/2020/05/15/ThinkingInJava/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Introduction-to-Objects"><a href="#Introduction-to-Objects" class="headerlink" title="Introduction to Objects"></a>Introduction to Objects</h2><h2 id="Everything-Is-an-Object"><a href="#Everything-Is-an-Object" class="headerlink" title="Everything Is an Object"></a>Everything Is an Object</h2><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><h2 id="Controlling-Execution"><a href="#Controlling-Execution" class="headerlink" title="Controlling Execution"></a>Controlling Execution</h2><h2 id="Initialization-amp-Cleanup"><a href="#Initialization-amp-Cleanup" class="headerlink" title="Initialization &amp; Cleanup"></a>Initialization &amp; Cleanup</h2><ul><li>访问static final constant(compile-time constant) ,that value can be read without causing the Initable class to be initialized.但是static field还是会的<blockquote><p>If a static field is not final, accessing it always requires linking (to allocate storage for the field) and initialization (to initialize that storage) before it can be read </p></blockquote></li></ul><h2 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h2><h2 id="Reusing-Classes"><a href="#Reusing-Classes" class="headerlink" title="Reusing Classes"></a>Reusing Classes</h2><h2 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h2><p><code>Father s=new Son();</code>//s只能调用Father的资源，除非(Son)s<br>Father是接口，调用方法时调用Son的实现</p><hr><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><hr><p>抽象类里的抽象方法可以逼迫子类重写抽象方法</p><h2 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes ***"></a>Inner Classes ***</h2><ul><li>外部类无法调用内部类资源,反过来可以</li></ul><hr><h2 id="Holding-Your-Objects"><a href="#Holding-Your-Objects" class="headerlink" title="Holding Your Objects ***"></a>Holding Your Objects ***</h2><ul><li><p>Linklist<br>linklist.getfirst(),element(),peek(),get the first element,<br> while remove(),removeFirst(),poll() get and remove the first element<br>addFirst() add to the first position,<br>while offer() and add() add to the last position</p></li><li><p>Arraylist<br>B<pet> b = A.subList(x,y); b所做的改变对A有影响</pet></p></li></ul><p>collection<t a>.toArray(T[] a)，返回的数组类型必须是T，没有泛型是object</t></p><ul><li>Utility(Collections and Arrays)</li></ul><ol><li><p>Collections<br>Collections.addAll( )比collection(Collections c) more quicker,and flexible</p></li><li><p>Arrays<br>Arrays.asList() notes :<br>1、Arrays.asList()不要乱用，底层其实还是数组。<br>2、如果使用了Arrays.asList()的话，最好不要使用其集合的操作方法。<br>3、List list = new ArrayList&lt;&gt;(Arrays.asList(“a”, “b”, “c”))可以在外面这样包一层真正的ArrayList。</p></li></ol><hr><h2 id="Error-Handling-with-Exceptions"><a href="#Error-Handling-with-Exceptions" class="headerlink" title="Error Handling with Exceptions *"></a>Error Handling with Exceptions *</h2><hr><p>捕捉了异常会继续往后走，靠系统捕捉不往后走</p><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings ***"></a>Strings ***</h2><h2 id="Type-Information"><a href="#Type-Information" class="headerlink" title="Type Information ***"></a>Type Information ***</h2><ul><li>获取class reference:</li></ul><p>1.有该对象，object.getClass();<br>2.没有该对象，Class.forName(“name”)(初始化)/X.class(不初始化)</p><ul><li><p>class reference转Object:<br><code>class.getInstance()</code>(要有默认构造器)</p></li><li><p>类加载机制:<br>java会为每一个class创建一个.class文件，当你创建它的对象时，JVM class loader 处理你的程序；当你调用它的static member,所有的class都会被动态加载到JVM里(构造方法也是static，因此new 一个对象作为调用static member)</p></li></ul><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><p>&lt;? extends T&gt;<br>&lt;? super  T&gt;</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays ***"></a>Arrays ***</h2><ul><li>填充数组方法：</li></ul><ol><li>填充同一类型(Arrays):<br><code>public static void fill(Object[] a, Object val)</code></li><li>填充指定类型<br>填充数组是基于填充容器<br><code>Generated.array(T[] a, Generator&lt;T&gt; gen)</code></li></ol><ul><li>six basic static utility methods :<br>equals(),fill(),sort(),binarySearch(),toString(),hashCode()</li></ul><ol><li><p>equals()判断 数组的长度及每个元素是否相等(Object.equals())</p></li><li><p>sort() 数组排序一种是默认排序(字典序)，一种是自定义<br>自定义排序：<br>有一个数组A[x],一般是用Arrays.sort(A[] a),A这个类必须实现Comparable重写compareTo(A a1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int compareTo(A a1)&#123;</span><br><span class="line">return (i &lt; a1.i ? -1 : (i == a1.i ? 0 : 1));</span><br><span class="line">&#125;(-1正序，1倒序)</span><br></pre></td></tr></table></figure></li></ol><p>也可以用Arrays.sort(A[] a，Collections.reverseOrder() )倒序</p><p>也可以用Arrays.sort(A[] a，Comparator c) Comparator子类来自定义哪个字段排序，重写的compare()方法语法与compareTo(）一样</p><p>在对String排序时，String.CASE_INSENSITIVE_ORDER 可忽略大小写</p><hr><h2 id="Containers-in-Depth"><a href="#Containers-in-Depth" class="headerlink" title="Containers in Depth ***"></a>Containers in Depth ***</h2><ul><li>填充容器方法：</li></ul><p>1.填充同一类型(工具类Collections)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections:</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o)</span><br><span class="line">public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj)</span><br></pre></td></tr></table></figure><p> 2.填充指定类型((既可以自定义也可以用RandomGenerator或CountingGenerator,RandomGenerator等工具类)因为几乎所有Collection的构造方法都有一个Collection参数来对其初始化<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Container(new CollectionData/CollectionData.list(Object o(? extend Genetator),int num))</span><br></pre></td></tr></table></figure></p><hr><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O ***"></a>I/O ***</h2><h2 id="Enumerated-Types"><a href="#Enumerated-Types" class="headerlink" title="Enumerated Types"></a>Enumerated Types</h2><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency ***"></a>Concurrency ***</h2><h4 id="Basic-threading"><a href="#Basic-threading" class="headerlink" title="Basic threading"></a>Basic threading</h4><hr><ul><li>Excutors</li></ul><ol><li>shutdown()，shutdownNow()区别<br>shutdown()有序关闭之前提交的任务，不关闭新的任务<br>shutdownNow()关闭所有正在执行的任务，尝试用interrupt关闭，<br>thread.interrupted()判断(without throwing an exception.)，sleep()的InterruptedException catch,wait()的InterruptedException catch等都可以结束，如果没有这些判断或catch InterruptedException,无法结束(详见JDK)</li></ol><blockquote><p>typical  implementations will cancel via {@link Thread#interrupt}, so any task that fails to respond to interrupts may never terminat</p></blockquote><ul><li><p>Daemon threads<br>设置thread deamon两种方式：threadfactory和thread.setDeamon(true)(before thread.start())</p></li><li><p>Joining a thread<br>thread.join()：A.join()指先等A走完</p></li></ul><h4 id="Sharing-resources"><a href="#Sharing-resources" class="headerlink" title="Sharing resources:"></a>Sharing resources:</h4><ul><li>Atomicity and volatility<blockquote><p>p854</p><p><strong>one object one lock</strong></p></blockquote><h4 id="Terminating-tasks"><a href="#Terminating-tasks" class="headerlink" title="Terminating tasks"></a>Terminating tasks</h4></li><li>Thread.currentThread().isInterrupted()用作判断，不改变thread status,而Thread.interrupted()用作termination,改变thread status</li></ul><h4 id="Cooperation-between-tasks"><a href="#Cooperation-between-tasks" class="headerlink" title="Cooperation between tasks"></a>Cooperation between tasks</h4><ul><li><p>wait(),notify(),notifyAll()<br>  1    in fact,wait(),notify(),notifyAll() are only used in synchronized methods or block,or it will throw IllegalMonitorStateException</p><pre><code>Class x{otherObject ob=new otherObject();synchronized(ob){wait()}}(synchronized object与调用wait的object不一致也会抛IllegalMonitorStateException)</code></pre></li></ul><pre><code>​    2   wait() will suspend this task and release the lock,only when notify/notifyall() being called,and this task reacquire the lock it released in wait(),can it be be waken.btw,方法走完也会释放锁3   wait()需要用同一object的notify()/notifyAll()才能唤醒</code></pre><hr><p>附录：</p><ul><li>net.mindview.util包： </li></ul><p>ConvertTo.primitive(primitive[] p)将primitive数组转成wrapper数组</p><hr><p><strong>这本书练习题及特别是答案涉及很多知识，特别不错</strong><br>在从前往后看时，先看的是中文版，到Containers in Depth才开始英文版<br>刚开始看英文版的时候没有一字一句看(1)，是抱着试看的态度，再加上每章看完没有提炼总结知识点(目录(1)需要记忆的(2))与难点(3)，现在回过头来虽然有点后悔，但是毕竟是第一本用心看的书(1)加上英文书(2)。</p><p>颜色解释：<br>绿色 非常重要 红色 重要<br>黄色 复习时没看 灰色 不懂<br>pages pdf目录 黄色代表从哪里开始到目录结束都没看<br>(Containers in Depth以上英文版没看过)</p>]]></content>
      
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
