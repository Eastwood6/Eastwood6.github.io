<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git pro notes</title>
      <link href="/2020/05/15/Git%20Pro%20Notes/"/>
      <url>/2020/05/15/Git%20Pro%20Notes/</url>
      
        <content type="html"><![CDATA[<p>pro git 2nd edition<br>%HOMEDRIVE%%HOMEPATH%</p><p>[TOC]</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h2 id="Git-Basics"><a href="#Git-Basics" class="headerlink" title="Git Basics"></a>Git Basics</h2><p><strong>git较其他vcs特点</strong></p><ul><li>nearly every operation is local</li><li>integrity</li><li>only add</li><li>three states: unmodified,modified,staged<br>(当你对modified文件staged,这些文件保存在staging area,然后会snapshot，当你commit的时候，文件还是在staging area，snapshots永久保存至git repository)</li></ul><hr><ul><li>Getting a Git Repository<br>create local Repository<br><code>git init</code> create a skeleton,if you wanna track these files:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br></pre></td></tr></table></figure></li></ul><p>copy from remote server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone url (name)</span><br></pre></td></tr></table></figure><p><strong>以上文件系统自动帮你commit</strong></p><ul><li>Recording Changes to the Repository</li></ul><ol><li><p>Staging Modified Files:<br>当git add后再修改该文件，git status查看时，会发现<br>Changes to be committed，Changes not staged for commit:<br>都有该文件，git add track 的是当时的版本，修改后并没有重新track</p></li><li><p>Short Status:<br><code>git status -s or git status --short</code><br>左边的表示staged,右边的表示modified，<br>修改一个文件时，是右边的M，add后是左边的M,在修改如果是本地文件是MM，如果是新建文件是AM，未作修改??</p></li><li><p>Ignoring Files<br>语法:  P46 </p><blockquote><p>gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。</p></blockquote></li><li><p>Viewing Your Staged and Unstaged Changes<br><code>git diff</code><br>git diff 比较的是staging area与原文件的不同<br><code>git diff --staged</code> 比较的是当前staged与last commit区别，如果没有commit，就是原文件<br><code>git diff --cached</code> 展示staged area</p></li><li><p>Committing Your Changes<br>commit之前可以先git status看下是否都在staged area,git commit也会将编辑器选项带过去<br>git commit 你会看到最新git status output,去掉注释或加一段message以留下commit message<br><code>git commit -m “message”</code>直接留下message提交<br><code>git commit -v</code>可以看到即将要提交哪些更改</p></li><li><p>Skipping the Staging Area</p><blockquote><p>command makes Git automatically stage every file that is already <strong>tracked</strong> before doing the commit, letting you skip the git add part</p></blockquote></li></ol><p>跳过git add直接将修改未staged git commit<br><code>git commit -a/git commit -a -m &#39;message&#39;/git commit -am &#39;message&#39;</code></p><ol start="7"><li><p>Removing Files<br><code>rm</code>删除working directory文件<br><code>git rm</code>同时删除index(staging area)和working directory文件<br>(<strong>commit 过的文件git rm没有提示，没有commit过的staged file会提示：</strong><code>the following file has changes staged in the index(use --cached to keep the file, or -f to force removal)</code>)(因为没有提交而无法恢复所以怕你误删)<br><code>git rm --cached README</code> git不再tracking README,改为本地保存<br><code>git rm log/\*.log</code> 删除指定目录<br><code>git rm \*~</code>删除所有以<code>*</code>结尾的文件</p><ol start="8"><li>Moving Files<br><code>rm/git rm oldname newname;</code></li></ol></li></ol><ul><li><p>Viewing the Commit History<br><code>git log</code> 查看项目提交完整记录<br>显示格式 P58   显示命令P60     显示输出限制P60<br><code>git log -p/-p -num</code> 查看项目提交完整详细记录/查看<strong>最近</strong>指定数目<br><code>git log --stat</code>查看类似 1 file changed, 0 insertions(+), 0 deletions(-)<br><code>git log --pretty=oneline</code> 简略输出一行 )<br><code>git log --pretty=format:&quot;%h %s&quot; --graph</code>(显示我的分支与合并历史)<br><code>git log --grep</code> 搜索commit message里的关键词<br><code>git log -S</code>搜索新增或删除代码里的关键词</p></li><li><p>Undoing Things</p></li></ul><ol><li><code>git commit (-m msg)--amend</code> 再次提交staging area(以防提交后忘了提交某文件或者想修改commit message)</li><li>Unstaging a Staged File<br><code>git reset [FILE]</code></li><li>Unmodifying a Modified File<br><code>git checkout [FILE]</code>(撤销就无法反撤销了，记住commit过的文件都有备份，但没有commit的没有备份)</li></ol><ul><li>Working with Remotes</li></ul><ol><li>Showing Your Remotes<br><code>git remote</code>查看你有配置过哪些remote servers,展示了每个你所明确的简称<br><code>git remote -v</code> 查看简称与url</li><li>Adding Remote Repositories<br><code>git remote add [shortname]  [url]</code></li><li>Fetching and Pulling from Your Remotes<br><code>git fetch [shortname]</code>  远程下载文件到相应分支中,(switch branch and will update automatically)</li></ol><p><code>git pull shortName branchName</code> ,远程下载文件到相应分支中，automatically tries to merge it into the code you’re currently working on.</p><ol start="4"><li>Pushing to Your Remotes<br><code>git push shortName branchName( :replaceName )</code> </li></ol><ul><li>(This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime)</li><li>push前所做的修改要提交</li><li>(新的branchName会自动创建branch)<br><code>git config --global credential.helper cache</code>(DONT TYPE YOUR PASSWORD EVERY TIME)</li></ul><ol start="5"><li>Inspecting a Remote<br><code>git remote show [shortName]</code>(在线查看shortName的branches、 head branch、pull、push url)</li><li>Removing and Renaming Remotes<br><code>git remote rename pb paul</code><br><code>git remote rm paul</code></li></ol><ul><li>Tagging<blockquote><p>Typically people use this functionality to mark release points</p></blockquote></li></ul><ol><li>Listing Your Tags<br><code>git tag</code>  Listing the available tags<br><code>git tag -l (name)</code>   search tag</li><li>Creating Tags</li><li>Annotated Tags<br><code>git tag -a tagname (-m tagMsg)</code><br><code>git tag show</code> tagname  (show  the tag data along with the commit)</li><li>Lightweight Tags<br><code>git tag tagname</code>  (and <code>git tag show</code> dont show any information except commit)</li><li>Tagging Later<br><code>git tag -a tagname commiit checksum (or part of it)</code></li><li>Sharing Tags<br><code>git push origin [tagname]</code><br><code>git push origin --tags</code> (transfer all of your tags to the remote server that are not already there)</li><li>Checking out Tags<br><code>git checkout -b version2 v2.0.0</code> (create a new branch at a specific tag)</li></ol><ul><li>Git Aliases<br><code>git config --global alias.custWords comands</code><br>eg: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout,</span><br><span class="line">git config --global alias.unstage &apos;reset HEAD --&apos;</span><br><span class="line">git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Git-Branching"><a href="#Git-Branching" class="headerlink" title="Git Branching"></a>Git Branching</h2><p>查看Git repository 保存哪些东西 P78<br>(git use the HEAD pointer to which the local branch you’re currently on,when you commit ,it will point to the latest commit automatically,when you use git checkout command,the HEAD switched to the branch you point to)</p><ul><li>Branches in a Nutshell </li></ul><ol><li>Creating a New Branch<br><code>git branch branchName</code>(create a new branch )</li><li>Switching Branches <blockquote><p>note that if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches</p></blockquote></li></ol><p><code>git checkout branchName</code></p><p><code>git log --oneline --decorate</code> (show which branch you currently are)</p><p><code>git log --oneline --decorate --graph --all</code> (show branch relation map)</p><ul><li>Basic Branching and Merging </li></ul><ol><li>Basic Branching<br><code>git checkout -b branchName</code> (create and enter that branch)<br><code>git branch -d branchName</code> delete a branch</li><li>Basic Merging<br><code>git merge branchName</code></li></ol><p><strong>fast forward</strong>    </p><blockquote><p>To phrase that another way, when you try to merge one commit with a commit that can be reached by following the first commit’s history, Git simplifies things by moving the pointer forward because there is no divergent work to merge together<br><strong>‘recursive’ strategy</strong> p92</p><ol start="3"><li>Basic Merge Conflicts<br>If you changed the same part of the same file differently in the two branches you’re merging together, Git won’be able to merge them cleanly<br>you get the warning after command git merge,you update the files,remove the conflict  in the file ,git add,and commit.  </li></ol></blockquote><p><code>git mergetool</code>(list useful tools)</p><p><strong>every updated file is synchronized in each  branch after merging</strong></p><ul><li><p>Branch Management<br><code>git branch</code>  (list branch)<br><code>git branch -v</code>(To see the last commit on each branch)<br><code>git branch --merged</code><br><code>git branch --no-merged</code></p></li><li><p>Branching Workflows </p></li></ul><ol><li><p>Long-Running Branches<br>stable branch-&gt;master<br>parallel branch-&gt;develop/next（used to test stability,whenever it gets to a stable state, it can be merged into master.It’s used to pull in topic branches (short-lived branches, like your earlier iss53 branch) when they’re ready, to make sure they pass all the tests and don’t introduce bugs.）</p></li><li><p>Topic Branches<br>这种工作流其实就是创建多种分支，不同的分支不同的目的，可以merge也可以delete,最终是为了这个Topic，所以叫Topic Branches Workflows</p></li></ol><ul><li>Remote Branches </li></ul><ol><li>Pushing </li><li>Tracking Branches<br><code>git checkout -b sf origin/serverfix</code>  create and use cusName to track remote branch branchName&gt;ones that track branches on other remotes, or don’t track the master branch.</li></ol><p><code>git branch -u origin/serverfix</code></p><p><code>git branch -vv</code>  list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.</p><ol start="3"><li>Pulling</li><li>Deleting Remote Branches<br><code>git push origin --delete serverfix</code> delete your serverfix branch from the server,not local</li></ol><ul><li>Rebasing </li></ul><ol><li><p>The Basic Rebase<br><code>git rebase master</code><br>rebase and merge 最终的snapshot相同只是历史不同，rebase按直线提交，而merge按终点提交</p></li><li><p>More Interesting Rebases<br><code>git rebase [basebranch] [topicbranch]</code> </p></li><li><p>The Perils of Rebasing </p></li><li><p>Rebase When You Rebase </p></li><li><p>Rebase vs. Merge </p><h2 id="Git-on-the-Server"><a href="#Git-on-the-Server" class="headerlink" title="Git on the Server"></a>Git on the Server</h2></li></ol><ul><li>The Protocols 122</li></ul><ol><li><p>Local Protocol 122</p></li><li><p>The HTTP Protocols 123</p></li><li><p>The SSH Protocol 126</p></li><li><p>The Git Protocol 126</p></li></ol><ul><li>Getting Git on a Server 127<br><code>git clone --bare my_project my_project.git</code> clone your repository to create a new bare repository<br><code>cp -Rf my_project/.git my_project.git</code></li></ul><ol><li>Putting the Bare Repository on a Server 128</li></ol><p><code>scp -r my_project.git user@git.example.com:/opt/git</code> store all your<br>Git repositories under the /opt/git directory.<br><code>git clone user@git.example.com:/opt/git/my_project.git</code>other users who have SSH access to the same server which has read-access to the /opt/git directory can clone your repository by running</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@git.example.com</span><br><span class="line">$ cd /opt/git/my_project.git</span><br><span class="line">$ git init --bare --shared</span><br></pre></td></tr></table></figure><blockquote><p>a user SSHs into a server and has write access to the /opt/git/my_project.git directory, they will also automatically have push access.<br>Git will automatically add group write permissions to a repository properly if you run the git init command with the –shared option.</p><ol start="2"><li>Small Setups 129</li></ol><ul><li>Generating Your SSH Public Key 130<br>By default, a user’s SSH keys are stored in that user’s ~/.ssh directory</li></ul></blockquote><p><code>ssh-keygen</code>  If you don’t have a pair of files named something like id_dsa or id_rsa (or you don’t even have a .ssh directory)</p><p><a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">creating an SSH key</a></p><ul><li>Setting Up the Server 131<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br><span class="line">$ su git</span><br><span class="line">$ cd</span><br><span class="line">$ mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ul><p>create a git user and a .ssh directory for that user.</p><ul><li><p>Git Daemon 134</p></li><li><p>Smart HTTP 135</p></li><li><p>GitWeb 137</p></li><li><p>GitLab 140</p></li></ul><ol><li><p>Installation 140</p></li><li><p>Administration 141</p></li><li><p>Basic Usage 144</p></li><li><p>Working Together 144</p></li></ol><ul><li>Third Party Hosted Options 145</li></ul><h2 id="Distributed-Git"><a href="#Distributed-Git" class="headerlink" title="Distributed Git"></a>Distributed Git</h2><ul><li>Distributed Workflows 147</li></ul><ol><li><p>Centralized Workflow 147</p></li><li><p>Integration-Manager Workflow 148</p></li><li><p>Dictator and Lieutenants Workflow 149</p></li><li><p>Workflows Summary 150</p></li></ol><ul><li>Contributing to a Project 151</li></ul><ol><li><p>Commit Guidelines 151<br><code>git diff --check</code></p><p>try to make each commit a logically separate changeset </p></li></ol><ul><li>use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit. If some of the changes modify the same file, try to use git add – patch to partially stage files (covered in detail in “Interactive Staging”).</li><li>The project snapshot at the tip of the branch is identical whether you do one commit or five </li><li>This approach also makes it easier to pull out or revert one of the changesets if you need to later. “Rewriting History” describes a number of useful Git tricks for rewriting history and interactively staging files </li><li>your messages should start with a single line that’s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation</li></ul><ol start="2"><li><p>Private Small Team 153</p></li><li><p>Private Managed Team 160</p></li></ol><p><strong>开发者无法合并到主分支，需要邮件或联系integrator who merge the branches that already pushed to the server</strong></p><p><code>git push -u origin brannch</code>  设置默认remote server<br><code>git push origin  master:branch</code> master覆盖remote shit branch</p><ol start="4"><li>Forked Public Project 166</li></ol><p><strong>开发者无法更新 branch on the project,需要fork project,然后push to the server, pull request</strong><br><code>git push -f myfork featureA</code><br><code>git request-pull origin/master myfork</code></p><ol start="5"><li>Public Project over E-Mail 170</li></ol><p><code>git format-patch -M origin/master</code>    it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.</p><p><code>git send-email *.patch</code>  the file you send must have format-patch as above and setting up in file .config</p><ol start="6"><li>Summary 173</li></ol><ul><li>Maintaining a Project 173</li></ul><ol><li><p>Working in Topic Branches 174<br><code>git branch sc/ruby_client master</code> create the branch based off your master branch like this</p></li><li><p>Applying Patches from E-mail 174</p></li><li><p>Checking Out Remote Branches 178</p></li><li><p>Determining What Is Introduced 179</p></li><li><p>Integrating Contributed Work 180</p></li><li><p>Tagging Your Releases 187</p></li><li><p>Generating a Build Number 188</p></li><li><p>Preparing a Release 189</p></li><li><p>The Shortlog 189</p></li></ol><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>notes:<br><strong>pull request之后，该请求分支里的修改会自动更新到pull request中</strong><br><strong>collaborator是无法merge branch的,所以也有pull request，所以pull request指的都是请求merge branch</strong></p><ul><li>Account Setup and Configuration 191</li></ul><ol><li><p>SSH Access 192</p></li><li><p>Your Avatar 194</p></li><li><p>Your Email Addresses 195</p></li><li><p>Two Factor Authentication 196</p></li></ol><ul><li><p>Contributing to a Project 197</p><ol><li><p>Forking Projects 197</p></li><li><p>The GitHub Flow 198<br><code>git diff master shit</code> 比较branch区别</p></li></ol><p>pull request：<br>当repository有pull request时，对repository有写权限的人才会看到<br>merge pull request button,当你merge时，不会是fast-forward方式，github只会创建merge commit,除非clone到本地操作再push到github,pull request会自动消失</p><ol start="3"><li>Advanced Pull Requests 206<br>REFERENCES:<br>可以利用 #  来引用pull request,commit(SHA),issue</li><li>Markdown 211<br>有上面标识默认是markdown格式<br><img src="en-resource://database/1389:1" alt="fd066b49b2130950bd1fcfe88e29a7f1.png"><h6 id="Task-Lists"><a href="#Task-Lists" class="headerlink" title="Task Lists:"></a>Task Lists:</h6>在pull request description里写task list 会在 pull request里看到<br><img src="en-resource://database/1391:1" alt="e8b6842a63e823c12eea086ca3cef036.png"><h6 id="Quoting"><a href="#Quoting" class="headerlink" title="Quoting:"></a>Quoting:</h6>用’&gt;’符号引用一段别人的评论/直接框选一段评论按R key，回复comment<h6 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji:"></a>Emoji:</h6>start with a <code>:</code> character, an autocompleter will help you find what you’re looking for<h6 id="Images"><a href="#Images" class="headerlink" title="Images:"></a>Images:</h6>you can drag or drop</li></ol></li><li><p>Maintaining a Project 216</p></li></ul><ol><li><p>Creating a New Repository 216</p></li><li><p>Adding Collaborators 218</p></li><li><p>Managing Pull Requests 220</p></li></ol><p><em>将指定pull request保存至本地</em>：<code>git ls-remote url</code> get a list of all the branches and tags and other references in the repository</p><p>SHA   refs/heads/sda        –&gt; branches<br>SHA   refs/pull/1/head      –&gt; sha(last commits sha to this (#num)                                           pull request )<br>SHA   refs/pull/3/merge    –&gt; represents the commit that would                             result if you push the “merge”button on the site.<br><code>git fetch origin refs/pull/958/head</code>pull down every Pull Request branch in one go without having to add a bunch of remotes.<br><em>将所有pull request refs保存至本地</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/libgit2/libgit2.git </span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</span><br></pre></td></tr></table></figure><p>编辑.git/config 然后<code>git fetch</code> 到本地refs/remotes/origin/pr/,想切换到哪个分支就<code>git checkout pr/num</code> ，</p><ol start="4"><li><p>Mentions and Notifications 225<br>@ character and it will begin to autocomplete with the names and usernames of people who are collaborators or contributors in the project.You can also mention a user who is not in that dropdown</p><ol start="5"><li><p>Special Files 229README 229</p></li><li><p>CONTRIBUTING 230</p></li><li><p>Project Administration 230</p></li></ol></li></ol><ul><li>Managing an organization 232</li></ul><ol><li><p>Organization Basics 232</p></li><li><p>Teams 233</p></li><li><p>Audit Log 235</p></li></ol><ul><li>Scripting GitHub 236</li></ul><ol><li><p>Hooks 237</p></li><li><p>The GitHub API 241</p></li><li><p>Basic Usage 242</p><ol start="4"><li><p>Commenting on an Issue 243</p></li><li><p>Changing the Status of a Pull Request 244</p></li><li><p>Octokit 246</p></li></ol></li></ol><h2 id="Git-Tools"><a href="#Git-Tools" class="headerlink" title="Git Tools"></a>Git Tools</h2><h2 id="Customizing-Git"><a href="#Customizing-Git" class="headerlink" title="Customizing Git"></a>Customizing Git</h2><h2 id="Git-and-Other-Systems"><a href="#Git-and-Other-Systems" class="headerlink" title="Git and Other Systems"></a>Git and Other Systems</h2><h2 id="Git-Internals"><a href="#Git-Internals" class="headerlink" title="Git Internals"></a>Git Internals</h2><hr><hr><p>issues</p><ol start="2"><li>测试： fast forward 合并两个文件同步吗  一个branch amend或commit /master 还在 git branch –merged吗recursive’ strategy呢</li></ol><p>note:</p><ol><li>新创建的要add,本地的原来的不用add</li><li>git commit -a -m ‘’/git commit –amend  区别在于<br>amend只是修改当前提交，做过的修改还要add,<br>而 -a 跳过add命令并创建了一个新提交</li><li>一个分支创建另一个分支 会显示在该分支的git branch –merged里</li></ol><p>ssh:</p><ol><li>xshell登录server时 ，用xshell自带的生成公钥并保存至server authorized_keys中，xshell会自动用私钥登录</li></ol><p>config:<br>git config commands作用在C:\Users\hp.gitconfig里</p><p>email:<br>    .gitconfig可以设置收发人<br>    好像只能发明文<br>    Gmail<a href="https://www.juvenal.me/personal/learning/2017/07/26/using-git-send-email-with-gmail-tls-on-macos/" target="_blank" rel="noopener">详见</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Grammar</title>
      <link href="/2020/05/15/Hexo%20Grammar/"/>
      <url>/2020/05/15/Hexo%20Grammar/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>nodejs,cnpm:</li></ul><p>首先要安装 Node.Js,顺带会有npm</p><p>本来是用npm来安装Hexo,但因为国内镜像系统较慢，利用npm安装cnpm也就是淘宝</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p><code>node -v</code>验证    <code>npm -v</code>验证</p><ul><li>hexo:</li></ul><p>安装Hexo:<code>cnpm install -g hexo-cli</code></p><p><code>hexo -v</code>验证</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>初始化博客</li></ul><p><code>mkdir blog</code></p><p><code>cd blog</code></p><p><code>sudo hexo init</code></p><ul><li>启动博客</li></ul><p><code>hexo s</code>用来预览</p><ul><li>创建博客</li></ul><p><code>hexo n &quot;name&quot;</code></p><h2 id="部署远端-cg-github"><a href="#部署远端-cg-github" class="headerlink" title="部署远端(cg:github)"></a>部署远端(cg:github)</h2><ul><li><p>安装git部署插件： <code>cnpm install --save hexo-deployer-git</code></p></li><li><p>配置远端地址_config.yml:</p></li></ul><p><code>vim _config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: https://github.com/Eastwood6/Eastwood6.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: git</span><br><span class="line">  repo: root@47.110.150.78:/home/git/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>部署<code>hexo d</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thingking In Java Notes</title>
      <link href="/2020/05/15/ThinkingInJava/"/>
      <url>/2020/05/15/ThinkingInJava/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Introduction-to-Objects"><a href="#Introduction-to-Objects" class="headerlink" title="Introduction to Objects"></a>Introduction to Objects</h2><h2 id="Everything-Is-an-Object"><a href="#Everything-Is-an-Object" class="headerlink" title="Everything Is an Object"></a>Everything Is an Object</h2><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><h2 id="Controlling-Execution"><a href="#Controlling-Execution" class="headerlink" title="Controlling Execution"></a>Controlling Execution</h2><h2 id="Initialization-amp-Cleanup"><a href="#Initialization-amp-Cleanup" class="headerlink" title="Initialization &amp; Cleanup"></a>Initialization &amp; Cleanup</h2><ul><li>访问static final constant(compile-time constant) ,that value can be read without causing the Initable class to be initialized.但是static field还是会的<blockquote><p>If a static field is not final, accessing it always requires linking (to allocate storage for the field) and initialization (to initialize that storage) before it can be read </p></blockquote></li></ul><h2 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h2><h2 id="Reusing-Classes"><a href="#Reusing-Classes" class="headerlink" title="Reusing Classes"></a>Reusing Classes</h2><h2 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h2><p><code>Father s=new Son();</code>//s只能调用Father的资源，除非(Son)s<br>Father是接口，调用方法时调用Son的实现</p><hr><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><hr><p>抽象类里的抽象方法可以逼迫子类重写抽象方法</p><h2 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes ***"></a>Inner Classes ***</h2><ul><li>外部类无法调用内部类资源,反过来可以</li></ul><hr><h2 id="Holding-Your-Objects"><a href="#Holding-Your-Objects" class="headerlink" title="Holding Your Objects ***"></a>Holding Your Objects ***</h2><ul><li><p>Linklist<br>linklist.getfirst(),element(),peek(),get the first element,<br> while remove(),removeFirst(),poll() get and remove the first element<br>addFirst() add to the first position,<br>while offer() and add() add to the last position</p></li><li><p>Arraylist<br>B<pet> b = A.subList(x,y); b所做的改变对A有影响</pet></p></li></ul><p>collection<t a>.toArray(T[] a)，返回的数组类型必须是T，没有泛型是object</t></p><ul><li>Utility(Collections and Arrays)</li></ul><ol><li><p>Collections<br>Collections.addAll( )比collection(Collections c) more quicker,and flexible</p></li><li><p>Arrays<br>Arrays.asList() notes :<br>1、Arrays.asList()不要乱用，底层其实还是数组。<br>2、如果使用了Arrays.asList()的话，最好不要使用其集合的操作方法。<br>3、List list = new ArrayList&lt;&gt;(Arrays.asList(“a”, “b”, “c”))可以在外面这样包一层真正的ArrayList。</p></li></ol><hr><h2 id="Error-Handling-with-Exceptions"><a href="#Error-Handling-with-Exceptions" class="headerlink" title="Error Handling with Exceptions *"></a>Error Handling with Exceptions *</h2><hr><p>捕捉了异常会继续往后走，靠系统捕捉不往后走</p><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings ***"></a>Strings ***</h2><h2 id="Type-Information"><a href="#Type-Information" class="headerlink" title="Type Information ***"></a>Type Information ***</h2><ul><li>获取class reference:</li></ul><p>1.有该对象，object.getClass();<br>2.没有该对象，Class.forName(“name”)(初始化)/X.class(不初始化)</p><ul><li><p>class reference转Object:<br><code>class.getInstance()</code>(要有默认构造器)</p></li><li><p>类加载机制:<br>java会为每一个class创建一个.class文件，当你创建它的对象时，JVM class loader 处理你的程序；当你调用它的static member,所有的class都会被动态加载到JVM里(构造方法也是static，因此new 一个对象作为调用static member)</p></li></ul><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><p>&lt;? extends T&gt;<br>&lt;? super  T&gt;</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays ***"></a>Arrays ***</h2><ul><li>填充数组方法：</li></ul><ol><li>填充同一类型(Arrays):<br><code>public static void fill(Object[] a, Object val)</code></li><li>填充指定类型<br>填充数组是基于填充容器<br><code>Generated.array(T[] a, Generator&lt;T&gt; gen)</code></li></ol><ul><li>six basic static utility methods :<br>equals(),fill(),sort(),binarySearch(),toString(),hashCode()</li></ul><ol><li><p>equals()判断 数组的长度及每个元素是否相等(Object.equals())</p></li><li><p>sort() 数组排序一种是默认排序(字典序)，一种是自定义<br>自定义排序：<br>有一个数组A[x],一般是用Arrays.sort(A[] a),A这个类必须实现Comparable重写compareTo(A a1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int compareTo(A a1)&#123;</span><br><span class="line">return (i &lt; a1.i ? -1 : (i == a1.i ? 0 : 1));</span><br><span class="line">&#125;(-1正序，1倒序)</span><br></pre></td></tr></table></figure></li></ol><p>也可以用Arrays.sort(A[] a，Collections.reverseOrder() )倒序</p><p>也可以用Arrays.sort(A[] a，Comparator c) Comparator子类来自定义哪个字段排序，重写的compare()方法语法与compareTo(）一样</p><p>在对String排序时，String.CASE_INSENSITIVE_ORDER 可忽略大小写</p><hr><h2 id="Containers-in-Depth"><a href="#Containers-in-Depth" class="headerlink" title="Containers in Depth ***"></a>Containers in Depth ***</h2><ul><li>填充容器方法：</li></ul><p>1.填充同一类型(工具类Collections)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections:</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o)</span><br><span class="line">public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj)</span><br></pre></td></tr></table></figure><p> 2.填充指定类型((既可以自定义也可以用RandomGenerator或CountingGenerator,RandomGenerator等工具类)因为几乎所有Collection的构造方法都有一个Collection参数来对其初始化<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Container(new CollectionData/CollectionData.list(Object o(? extend Genetator),int num))</span><br></pre></td></tr></table></figure></p><hr><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O ***"></a>I/O ***</h2><h2 id="Enumerated-Types"><a href="#Enumerated-Types" class="headerlink" title="Enumerated Types"></a>Enumerated Types</h2><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency ***"></a>Concurrency ***</h2><h4 id="Basic-threading"><a href="#Basic-threading" class="headerlink" title="Basic threading"></a>Basic threading</h4><hr><ul><li>Excutors</li></ul><ol><li>shutdown()，shutdownNow()区别<br>shutdown()有序关闭之前提交的任务，不关闭新的任务<br>shutdownNow()关闭所有正在执行的任务，尝试用interrupt关闭，<br>thread.interrupted()判断(without throwing an exception.)，sleep()的InterruptedException catch,wait()的InterruptedException catch等都可以结束，如果没有这些判断或catch InterruptedException,无法结束(详见JDK)</li></ol><blockquote><p>typical  implementations will cancel via {@link Thread#interrupt}, so any task that fails to respond to interrupts may never terminat</p></blockquote><ul><li><p>Daemon threads<br>设置thread deamon两种方式：threadfactory和thread.setDeamon(true)(before thread.start())</p></li><li><p>Joining a thread<br>thread.join()：A.join()指先等A走完</p></li></ul><h4 id="Sharing-resources"><a href="#Sharing-resources" class="headerlink" title="Sharing resources:"></a>Sharing resources:</h4><ul><li>Atomicity and volatility<blockquote><p>p854</p><p><strong>one object one lock</strong></p></blockquote><h4 id="Terminating-tasks"><a href="#Terminating-tasks" class="headerlink" title="Terminating tasks"></a>Terminating tasks</h4></li><li>Thread.currentThread().isInterrupted()用作判断，不改变thread status,而Thread.interrupted()用作termination,改变thread status</li></ul><h4 id="Cooperation-between-tasks"><a href="#Cooperation-between-tasks" class="headerlink" title="Cooperation between tasks"></a>Cooperation between tasks</h4><ul><li><p>wait(),notify(),notifyAll()<br>  1    in fact,wait(),notify(),notifyAll() are only used in synchronized methods or block,or it will throw IllegalMonitorStateException</p><pre><code>Class x{otherObject ob=new otherObject();synchronized(ob){wait()}}(synchronized object与调用wait的object不一致也会抛IllegalMonitorStateException)</code></pre></li></ul><pre><code>​    2   wait() will suspend this task and release the lock,only when notify/notifyall() being called,and this task reacquire the lock it released in wait(),can it be be waken.btw,方法走完也会释放锁3   wait()需要用同一object的notify()/notifyAll()才能唤醒</code></pre><hr><p>附录：</p><ul><li>net.mindview.util包： </li></ul><p>ConvertTo.primitive(primitive[] p)将primitive数组转成wrapper数组</p><hr><p><strong>这本书练习题及特别是答案涉及很多知识，特别不错</strong><br>在从前往后看时，先看的是中文版，到Containers in Depth才开始英文版<br>刚开始看英文版的时候没有一字一句看(1)，是抱着试看的态度，再加上每章看完没有提炼总结知识点(目录(1)需要记忆的(2))与难点(3)，现在回过头来虽然有点后悔，但是毕竟是第一本用心看的书(1)加上英文书(2)。</p><p>颜色解释：<br>绿色 非常重要 红色 重要<br>黄色 复习时没看 灰色 不懂<br>pages pdf目录 黄色代表从哪里开始到目录结束都没看<br>(Containers in Depth以上英文版没看过)</p>]]></content>
      
      
      
        <tags>
            
            <tag> -Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
